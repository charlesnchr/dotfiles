#!/usr/bin/env bash
set -e  # Exit on error

# Cache configuration
CACHE_FILE="$HOME/.cache/claude_usage_cache.json"
RAW_CACHE_FILE="$HOME/.cache/claude_usage_cache_raw.txt"
CACHE_MAX_AGE=300  # 5 minutes in seconds

# Use a fixed session name to prevent concurrent fetches
SESSION_NAME="claude-usage-fetch"
LOCK_FILE="$HOME/.cache/claude_usage.lock"

# Parse arguments
SHOW_RAW=false
if [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]]; then
    cat <<EOF
Usage: $(basename "$0") [OPTIONS]

Fetch Claude Code usage statistics with intelligent caching.

OPTIONS:
    --raw       Show raw tmux output instead of JSON
    --cleanup   Clean up stale tmux sessions and lock files
    --help, -h  Show this help message

CACHING:
    Results are cached for 5 minutes in:
      JSON: $CACHE_FILE
      Raw:  $RAW_CACHE_FILE

OUTPUT:
    Default: Structured JSON with usage percentages and reset times
    --raw:   Raw terminal output from Claude Code TUI

EXAMPLES:
    # Get JSON output (default)
    $(basename "$0")

    # Get raw terminal output
    $(basename "$0") --raw

    # Clean up stale sessions
    $(basename "$0") --cleanup

    # Parse JSON with jq
    $(basename "$0") | jq '.current_session.percentage'
EOF
    exit 0
fi

if [[ "$1" == "--cleanup" ]]; then
    echo "Cleaning up stale claude-usage sessions..." >&2
    # Kill any sessions starting with claude-usage (including fetch session)
    for session in $(tmux list-sessions -F '#{session_name}' 2>/dev/null | grep '^claude-usage' || true); do
        echo "  Killing session: $session" >&2
        tmux kill-session -t "$session" 2>/dev/null || true
    done
    # Remove lock file
    rm -f "$LOCK_FILE"
    echo "Cleanup complete" >&2
    exit 0
fi

if [[ "$1" == "--raw" ]]; then
    SHOW_RAW=true
fi

# Ensure cache directory exists
mkdir -p "$(dirname "$CACHE_FILE")" 2>/dev/null

# Helper function to get file age
get_file_age() {
    local file="$1"
    if [[ "$OSTYPE" == "darwin"* ]]; then
        echo $(( $(date +%s) - $(stat -f %m "$file" 2>/dev/null || echo "0") ))
    else
        echo $(( $(date +%s) - $(stat -c %Y "$file" 2>/dev/null || echo "0") ))
    fi
}

# Check if cache exists and is fresh
if [ -f "$CACHE_FILE" ]; then
    file_age=$(get_file_age "$CACHE_FILE")
    if [ $file_age -lt $CACHE_MAX_AGE ]; then
        # Cache is fresh, return it
        if [ "$SHOW_RAW" = true ]; then
            cat "$RAW_CACHE_FILE"
        else
            cat "$CACHE_FILE"
        fi
        exit 0
    fi
fi

# Helper to get session age in seconds
get_session_age() {
    local session_name="$1"
    if ! tmux has-session -t "$session_name" 2>/dev/null; then
        echo "9999"
        return
    fi

    local created=$(tmux display-message -t "$session_name" -p '#{session_created}' 2>/dev/null || echo "0")
    local now=$(date +%s)
    echo $((now - created))
}

# Check if a fetch session already exists
if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
    session_age=$(get_session_age "$SESSION_NAME")

    # If session is older than 90 seconds, it's likely stale - kill it
    if [ "$session_age" -gt 90 ]; then
        echo "Killing stale fetch session (${session_age}s old)..." >&2
        tmux kill-session -t "$SESSION_NAME" 2>/dev/null || true
        rm -f "$LOCK_FILE"
    else
        # Another fetch is in progress and it's recent
        echo "Fetch already in progress (${session_age}s old), using cached data..." >&2

        # Return cache if available (even if stale)
        if [ -f "$CACHE_FILE" ]; then
            if [ "$SHOW_RAW" = true ]; then
                cat "$RAW_CACHE_FILE"
            else
                cat "$CACHE_FILE"
            fi
            exit 0
        else
            # No cache yet, wait briefly for initial fetch
            sleep 2
            if [ -f "$CACHE_FILE" ]; then
                if [ "$SHOW_RAW" = true ]; then
                    cat "$RAW_CACHE_FILE"
                else
                    cat "$CACHE_FILE"
                fi
                exit 0
            fi
        fi

        echo "Error: Fetch in progress but no cache available" >&2
        exit 1
    fi
fi

# Check for stale lock
if [ -f "$LOCK_FILE" ]; then
    lock_age=$(get_file_age "$LOCK_FILE")
    if [ $lock_age -gt 120 ]; then
        echo "Removing stale lock (${lock_age}s old)..." >&2
        rm -f "$LOCK_FILE"
    fi
fi

# Try to acquire lock
if [ -f "$LOCK_FILE" ]; then
    echo "Lock file exists, using cached data..." >&2
    if [ -f "$CACHE_FILE" ]; then
        if [ "$SHOW_RAW" = true ]; then
            cat "$RAW_CACHE_FILE"
        else
            cat "$CACHE_FILE"
        fi
        exit 0
    fi
    echo "Error: Lock exists but no cache available" >&2
    exit 1
fi

# Acquire lock
echo $$ > "$LOCK_FILE"

# Cache is stale or doesn't exist, fetch new data
echo "Fetching fresh usage data..." >&2

# Cleanup function to ensure session and lock are always removed
cleanup_session() {
    if [ -n "$SESSION_NAME" ]; then
        tmux kill-session -t "$SESSION_NAME" 2>/dev/null || true
    fi
    rm -f "$LOCK_FILE"
}

# Set trap to cleanup on exit/interrupt
trap cleanup_session EXIT INT TERM

# Create a new detached tmux session
tmux new-session -d -s "$SESSION_NAME" -x 120 -y 40 "zsh" 2>/dev/null || {
    echo "Error: Failed to create tmux session" >&2
    exit 1
}

# Wait for session to initialize
sleep 2

# Send the claude command
tmux send-keys -t "$SESSION_NAME" 'claude "/usage"' C-m 2>/dev/null

# Intelligent polling: wait for output to stabilize
echo "Waiting for Claude to render usage screen..." >&2
max_wait=60
poll_interval=3
elapsed=0
prev_output=""
stable_count=0
usage_found=false

while [ $elapsed -lt $max_wait ]; do
    sleep "$poll_interval"
    elapsed=$((elapsed + poll_interval))

    # Capture current output
    current_output=$(tmux capture-pane -t "$SESSION_NAME" -p 2>/dev/null || echo "")

    # Check if usage content has appeared
    if echo "$current_output" | grep -q "Current session"; then
        usage_found=true
    fi

    # Only check for stability after usage content appears
    if [ "$usage_found" = true ]; then
        if [ "$current_output" = "$prev_output" ] && [ -n "$current_output" ]; then
            stable_count=$((stable_count + 1))
            if [ $stable_count -ge 2 ]; then
                echo "Output stabilized after ${elapsed}s" >&2
                break
            fi
        else
            stable_count=0
        fi
    fi

    prev_output="$current_output"
done

# Hard timeout - exit after max_wait regardless
if [ $elapsed -ge $max_wait ]; then
    if [ "$usage_found" = false ]; then
        echo "Error: Usage screen did not appear within ${max_wait}s" >&2
        exit 1
    else
        echo "Warning: Output did not stabilize within ${max_wait}s, using last capture" >&2
    fi
fi

# Final capture
raw_output=$(tmux capture-pane -t "$SESSION_NAME" -p 2>/dev/null)

# Parse the output into JSON (session cleanup handled by trap)
parse_usage_to_json() {
    local input="$1"

    # Extract percentages and reset times using grep and sed
    # Use larger context window to handle variable line breaks in the output
    session_pct=$(echo "$input" | grep -A4 "Current session" | grep "used" | sed -E 's/.*[^0-9]([0-9]+)%.*/\1/' | head -1)
    session_pct=${session_pct:-0}
    session_reset=$(echo "$input" | grep -A4 "Current session" | grep "Resets" | sed -E 's/.*Resets (.+)/\1/')

    week_all_pct=$(echo "$input" | grep -A5 "Current week (all models)" | grep "used" | sed -E 's/.*[^0-9]([0-9]+)%.*/\1/' | head -1)
    week_all_pct=${week_all_pct:-0}
    week_all_reset=$(echo "$input" | grep -A5 "Current week (all models)" | grep "Resets" | sed -E 's/.*Resets (.+)/\1/')

    opus_pct=$(echo "$input" | grep -A4 "Current week (Opus)" | grep "used" | sed -E 's/.*[^0-9]([0-9]+)%.*/\1/' | head -1)
    opus_pct=${opus_pct:-0}
    opus_reset=$(echo "$input" | grep -A4 "Current week (Opus)" | grep "Resets" | sed -E 's/.*Resets (.+)/\1/')

    # Get timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    # Build JSON
    cat <<EOF
{
  "timestamp": "$timestamp",
  "current_session": {
    "percentage": $session_pct,
    "resets": "$session_reset"
  },
  "current_week_all_models": {
    "percentage": $week_all_pct,
    "resets": "$week_all_reset"
  },
  "current_week_opus": {
    "percentage": $opus_pct,
    "resets": ${opus_reset:+\"$opus_reset\"}${opus_reset:-null}
  }
}
EOF
}

# Parse and save JSON
json_output=$(parse_usage_to_json "$raw_output")

# Save both raw and JSON to cache
echo "$raw_output" > "$RAW_CACHE_FILE"
echo "$json_output" > "$CACHE_FILE"

# Output the result
if [ "$SHOW_RAW" = true ]; then
    cat "$RAW_CACHE_FILE"
else
    cat "$CACHE_FILE"
fi
